<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Physics (Clean Production)</title>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/ultra_2026.css">
    <style> body { margin: 0; overflow: hidden; background-color: #030304; } </style>
</head>
<body>
    <div class="bg-base-layer"></div>
    <div class="social-nebula">
        <!-- Icons -->
        <div class="signal sig-lg"><i class="ri-openai-fill"></i></div>
        <div class="signal sig-md"><img src="https://cdn.simpleicons.org/whatsapp/white" alt="WhatsApp"></div>
        <div class="signal sig-sm"><img src="https://cdn.simpleicons.org/snapchat/white" alt="Snapchat"></div>
        <div class="signal sig-md"><img src="https://cdn.simpleicons.org/tiktok/white" alt="TikTok"></div>
        <div class="signal sig-lg"><img src="https://cdn.simpleicons.org/instagram/white" alt="Instagram"></div>
        <div class="signal sig-md"><i class="ri-robot-2-line"></i></div>
        <div class="signal sig-sm"><img src="https://cdn.simpleicons.org/googlegemini/white" alt="Gemini"></div>
        <div class="signal sig-lg"><img src="https://cdn.simpleicons.org/facebook/white" alt="Facebook"></div>
        <div class="signal sig-md"><img src="https://cdn.simpleicons.org/youtube/white" alt="YouTube"></div>
        <div class="signal sig-lg"><i class="ri-microsoft-fill"></i></div>
        <div class="signal sig-sm"><img src="https://cdn.simpleicons.org/anthropic/white" alt="Anthropic"></div>
        <div class="signal sig-md"><img src="https://cdn.simpleicons.org/google/white" alt="Google"></div>
        <div class="signal sig-sm"><i class="ri-search-eye-line"></i></div>
        <div class="signal sig-md"><i class="ri-zoom-in-line"></i></div>
        <div class="signal sig-sm"><i class="ri-slack-fill"></i></div>
        <div class="signal sig-md"><i class="ri-trello-fill"></i></div>
        <div class="signal sig-sm"><i class="ri-heart-fill" style="color:#ff4757;"></i></div>
        <div class="signal sig-md"><i class="ri-shopping-cart-fill"></i></div>
    </div>

    <script>
        /**
         * NEBULA PHYSICS ENGINE v10.0 (Production Ready)
         * Vertical Dual-Flow System with Kinetic Repulsion
         */
        class NebulaPhysics {
            constructor() {
                this.container = document.querySelector('.social-nebula');
                this.signals = Array.from(document.querySelectorAll('.social-nebula .signal'));
                this.particles = [];
                
                // System Config
                this.config = {
                    baseSpeed: 0.3,       // Rising speed (Slow drift)
                    fallSpeed: 0.5,       // Falling speed (Faster, natural gravity)
                    collisionPadding: 8,  // Balanced gap
                    drag: 0.96,           // Horizontal air resistance
                    recovery: 0.02,       // Force pulling back to vertical path
                    downFlowChance: 0.2,  // 20% of icons fall down
                    spawnInterval: 300,   // Milliseconds between icon spawns
                    sideBias: 0.35        // 35% width for each side cluster
                };

                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.init();
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);

                window.addEventListener('resize', () => this.handleResize());
            }

            // ---------------------------------------------------------
            // 1. INITIALIZATION & METRICS
            // ---------------------------------------------------------

            getMetrics(el) {
                // Balanced Radii
                if (el.classList.contains('sig-lg')) return 26; 
                if (el.classList.contains('sig-md')) return 18; 
                if (el.classList.contains('sig-sm')) return 12; 
                return 16;
            }

            getBiasedX() {
                const { sideBias } = this.config;
                const rand = Math.random();
                
                // 45% Left Cluster, 45% Right Cluster, 10% Sparse Center
                if (rand < 0.45) {
                    return Math.random() * (this.width * sideBias);
                } else if (rand < 0.90) {
                    const rightStart = this.width * (1 - sideBias);
                    return rightStart + Math.random() * (this.width * sideBias);
                } else {
                    const centerWidth = this.width * (1 - 2 * sideBias);
                    const centerStart = this.width * sideBias;
                    return centerStart + Math.random() * centerWidth;
                }
            }

            init() {
                const placed = [];
                
                this.signals.forEach((el, index) => {
                    // Reset Styles
                    Object.assign(el.style, {
                        position: 'absolute', left: '0', top: '0', margin: '0',
                        willChange: 'transform', opacity: '0',
                        transition: 'opacity 2s ease'
                    });
                    
                    const radius = this.getMetrics(el);

                    // Find Non-Overlapping Position
                    let x, y, safe, attempts = 0;
                    while(attempts < 150) {
                        safe = true;
                        x = this.getBiasedX();
                        y = Math.random() * this.height;
                        
                        // Simple distance check against already placed items
                        for (const p of placed) {
                            const dx = x - p.x;
                            const dy = y - p.y;
                            if (Math.sqrt(dx*dx + dy*dy) < (radius + p.radius + 15)) {
                                safe = false; break;
                            }
                        }
                        if (safe) break;
                        attempts++;
                    }

                    // Determine Flow Direction & Speed
                    const isFalling = Math.random() < this.config.downFlowChance;
                    // Falling uses fallSpeed, Rising uses baseSpeed
                    const speed = isFalling ? this.config.fallSpeed : this.config.baseSpeed;
                    const baseVy = isFalling ? speed : -speed;

                    // Create Particle
                    this.particles.push({
                        el, x, y, radius, 
                        vx: 0, 
                        vy: baseVy,
                        baseVy: baseVy, 
                        mass: radius, 
                        active: false,
                        isFalling
                    });

                    placed.push({ x, y, radius });

                    // Sequential Spawn
                    setTimeout(() => {
                        const p = this.particles[index];
                        p.active = true;
                        p.el.style.opacity = '0.6';
                    }, index * this.config.spawnInterval); 
                });
            }

            handleResize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
            }

            // ---------------------------------------------------------
            // 2. MAIN LOOP
            // ---------------------------------------------------------

            animate() {
                this.particles.forEach(p => {
                    if (!p.active) return;

                    // A) Move
                    p.x += p.vx;
                    p.y += p.vy;

                    // B) Restore Flow (Dampen Bounce)
                    p.vx *= this.config.drag; 
                    p.vy = p.vy * (1 - this.config.recovery) + p.baseVy * this.config.recovery;

                    // C) Wrap Around Screen
                    this.handleWrap(p);
                });

                // D) Resolve Collisions (Double Pass for Stability)
                for(let k=0; k<2; k++) {
                    for (let i = 0; i < this.particles.length; i++) {
                        for (let j = i + 1; j < this.particles.length; j++) {
                            this.resolveCollision(this.particles[i], this.particles[j]);
                        }
                    }
                }

                // E) Render
                this.particles.forEach(p => {
                    // Offset by radius to center the div on physics point
                    p.el.style.transform = `translate3d(${p.x - p.radius}px, ${p.y - p.radius}px, 0)`;
                });

                requestAnimationFrame(this.animate);
            }

            handleWrap(p) {
                // Horizontal Wrap
                if (p.x < -p.radius) p.x = this.width + p.radius;
                if (p.x > this.width + p.radius) p.x = -p.radius;
                
                // Vertical Wrap
                if (p.isFalling) {
                    if (p.y > this.height + 50) {
                        p.y = -50;
                        p.x = this.getBiasedX();
                    }
                } else {
                    if (p.y < -50) {
                        p.y = this.height + 50;
                        p.x = this.getBiasedX();
                    }
                }
            }

            // ---------------------------------------------------------
            // 3. PHYSICS ENGINE
            // ---------------------------------------------------------

            resolveCollision(p1, p2) {
                if (!p1.active || !p2.active) return;

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distSq = dx * dx + dy * dy;
                const minDist = p1.radius + p2.radius + this.config.collisionPadding;

                // Check collision using squared distance (faster)
                if (distSq < minDist * minDist) {
                    const dist = Math.sqrt(distSq) || 0.001;
                    const overlap = minDist - dist;
                    const nx = dx / dist; // Normal Vector X
                    const ny = dy / dist; // Normal Vector Y

                    // 1. Separation (Move apart to unstick)
                    const force = overlap * 0.5;
                    p1.x -= nx * force;
                    p1.y -= ny * force;
                    p2.x += nx * force;
                    p2.y += ny * force;

                    // 2. Elastic Bounce (Velocity Exchange)
                    const v1n = p1.vx * nx + p1.vy * ny;
                    const v2n = p2.vx * nx + p2.vy * ny;

                    // If already moving apart, skip
                    if (v1n < v2n) return;

                    // Momentum Calculation
                    const m1 = p1.mass;
                    const m2 = p2.mass;
                    const v1nFinal = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
                    const v2nFinal = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);

                    const dv1 = v1nFinal - v1n;
                    const dv2 = v2nFinal - v2n;

                    p1.vx += nx * dv1;
                    p1.vy += ny * dv1;
                    p2.vx += nx * dv2;
                    p2.vy += ny * dv2;
                }
            }
        }

        // Boot
        new NebulaPhysics();
    </script>
</body>
</html>